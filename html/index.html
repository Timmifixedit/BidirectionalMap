<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bidirectional Map: bidirectional_map</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bidirectional Map
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">bidirectional_map </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Implementation of a bidirectional associative container in c++. Its goal is to behave similarly to popular stl containers like <code>std::unordered_map</code> while providing efficient lookup from key to value as well as from value to key. </p>
<h1><a class="anchor" id="autotoc_md1"></a>
Properties</h1>
<p>The <code>bidirectional_map</code> container contains pairs of values of type K1 and K2.</p><ul>
<li>Objects in the container are immutable, neither values of type K1 nor values of type K2 can be modified to ensure the integrity of the underlying associative containers</li>
<li>The container supports the use of different associative containers as base. The default base container is <code>std::unordered_map</code> for both forward and inverse lookup. Other tested containers are <code>std::map</code> as well as <code>std::multimap</code> and <code>std::unordered_multimap</code>.</li>
<li>The mapping from values of K1 to values of K2 is enforced to be injective if the underlying containers for both forward and inverse lookup contain unique keys (like in the default case). This means that for example two pairs (k1, k2) and (k1', k2') can only be inserted at the same time if k1 != k1' <b>and</b> k2 != k2'. The use of multimaps as base containers relaxes this constraint.</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Code Example</h1>
<p>An instance of <code>bidirectional_map</code> can be created similarly to <code>std::unordered_map</code>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;bidirectional_map.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// empty container</span></div>
<div class="line"><a class="code" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map&lt;std::string, int&gt;</a> map;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// using initializer list</span></div>
<div class="line"><a class="code" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map&lt;std::string, int&gt;</a> map1 = {{<span class="stringliteral">&quot;Test&quot;</span>, 1}, {<span class="stringliteral">&quot;Hello&quot;</span>, 2}}; </div>
<div class="line"> </div>
<div class="line"><span class="comment">// from same container type</span></div>
<div class="line"><a class="code" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map&lt;std::string, int&gt;</a> map3(map1.<a class="code" href="classbimap_1_1bidirectional__map.html#a7ebfac1450e9aef4926db96a0365fe0c">begin</a>(), map1.<a class="code" href="classbimap_1_1bidirectional__map.html#a20d7c9ce77dd7b536dcac6e2eead87fa">end</a>());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// from different container type</span></div>
<div class="line">std::unordered_map&lt;std::string, int&gt; values = {{<span class="stringliteral">&quot;abc&quot;</span>, 1}, {<span class="stringliteral">&quot;def&quot;</span>, 2}};</div>
<div class="line"><a class="code" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map&lt;std::string, int&gt;</a> map2(values.begin(), values.end());</div>
</div><!-- fragment --><p>From the items used for initialization only unique ones are inserted (see properties). Further items can be inserted using the <code>emplace</code> method </p><div class="fragment"><div class="line"><a class="code" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map&lt;std::string, int&gt;</a> map;</div>
<div class="line">map.emplace(<span class="stringliteral">&quot;NewItem&quot;</span>, 17); <span class="comment">// constructs new item in place</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// no insertion. 17 already exists in the container. Returns iterator to (&quot;NewItem&quot;, 17)</span></div>
<div class="line"><span class="keyword">auto</span> [iterator, inserted] = map.emplace(<span class="stringliteral">&quot;AnotherItem&quot;</span>, 17);</div>
</div><!-- fragment --><p>Item lookup: </p><div class="fragment"><div class="line"><a class="code" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map&lt;std::string, int&gt;</a> map{{<span class="stringliteral">&quot;NewItem&quot;</span>, 12}, {<span class="stringliteral">&quot;Stuff&quot;</span>, 17}};</div>
<div class="line"><span class="keyword">auto</span> location = map.<a class="code" href="classbimap_1_1bidirectional__map.html#a0947502711494ca13e834d07728d42dd">find</a>(<span class="stringliteral">&quot;NewItem&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (location != map.<a class="code" href="classbimap_1_1bidirectional__map.html#a20d7c9ce77dd7b536dcac6e2eead87fa">end</a>()) {</div>
<div class="line">    std::cout &lt;&lt; location-&gt;first &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (map.<a class="code" href="classbimap_1_1bidirectional__map.html#a1545d66d8b6ad045c54ba8e0df542f36">contains</a>(<span class="stringliteral">&quot;Stuff&quot;</span>)) {</div>
<div class="line">    std::cout &lt;&lt; map.<a class="code" href="classbimap_1_1bidirectional__map.html#a40c1e68b6431da986028fb5d9d7a2b41">at</a>(<span class="stringliteral">&quot;Stuff&quot;</span>) &lt;&lt; std::endl; <span class="comment">// at is only available when using underlying container that enforces</span></div>
<div class="line">                                               <span class="comment">// unique keys</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3"></a>
Inverse Access</h2>
<p>Using the <code>inverse()</code> member, inverse lookup and insertion is possible: </p><div class="fragment"><div class="line"><a class="code" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map&lt;std::string, int&gt;</a> map;</div>
<div class="line">map.<a class="code" href="classbimap_1_1bidirectional__map.html#aa2c2540101bed9d42a489313af5fb8df">inverse</a>().emplace(123, <span class="stringliteral">&quot;one two three&quot;</span>); <span class="comment">// inverse insertion</span></div>
<div class="line"><span class="keyword">auto</span> invLocation = map.<a class="code" href="classbimap_1_1bidirectional__map.html#aa2c2540101bed9d42a489313af5fb8df">inverse</a>().find(123); <span class="comment">// inverse lookup</span></div>
<div class="line">std::cout &lt;&lt; invLocation-&gt;first &lt;&lt; std::endl; <span class="comment">// prints &#39;123&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// inverse of inverse() is again the original</span></div>
<div class="line"><span class="keyword">auto</span> location = map.<a class="code" href="classbimap_1_1bidirectional__map.html#aa2c2540101bed9d42a489313af5fb8df">inverse</a>().inverse().find(<span class="stringliteral">&quot;one two three&quot;</span>);</div>
</div><!-- fragment --><p><code>inverse()</code> returns a reference to <code>bidirectional_map</code> where the template types K1 and K2 are reversed. It behaves exactly like the original map except... well the other way around. Even the iterator members are reversed. Copying the <code>inverse()</code> container is allowed and will copy the container contents. Moving from <code>inverse()</code> is also allowed and behaves as expected. </p><div class="fragment"><div class="line"><a class="code" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map&lt;std::string, int&gt;</a> map; <span class="comment">// map from std::string -&gt; int</span></div>
<div class="line"><span class="keyword">auto</span> inverse = map.<a class="code" href="classbimap_1_1bidirectional__map.html#aa2c2540101bed9d42a489313af5fb8df">inverse</a>(); <span class="comment">// independent (copied) container of reversed type (int -&gt; string)</span></div>
<div class="line"><span class="keyword">auto</span> &amp;inverseRef = map.<a class="code" href="classbimap_1_1bidirectional__map.html#aa2c2540101bed9d42a489313af5fb8df">inverse</a>(); <span class="comment">// inverse access to the same container</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4"></a>
Custom Map Base Container</h2>
<p>It is possible to specify a custom map base container for forward lookup as well as for inverse lookup. The default map base type is <code>std::unordered_map</code> for forward access as well as for inverse access. Another possible map base type is <code>std::map</code>: </p><div class="fragment"><div class="line"><span class="comment">// only forward access uses the ordered map std::map.</span></div>
<div class="line"><span class="comment">// Inverse access is till provided through std::unordered_map</span></div>
<div class="line"><a class="code" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map&lt;std::string, int, std::map&gt;</a> map;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Both forward and inverse access use std::map</span></div>
<div class="line"><a class="code" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map&lt;std::string, int, std::map, std::map&gt;</a> map1;</div>
</div><!-- fragment --><p>Another scenario for using a different map base type is when you need to specify for example a custom hash function: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyString {...}; <span class="comment">// Custom data structure with no default std::hash specialization</span></div>
<div class="line"><span class="keyword">struct </span>MyHash {...}; <span class="comment">// Custom hash struct</span></div>
<div class="line"><span class="keyword">struct </span>MyComparator {...}; <span class="comment">// Custom comparator necessary for std::unordered_map</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</div>
<div class="line"><span class="keyword">using</span> BaseMap = std::unordered_map&lt;T, U, MyHash, MyComparator&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// for inverse access the default std::unordered_map is sufficient</span></div>
<div class="line"><a class="code" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map&lt;MyString, int, BaseMap&gt;</a> map;</div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="ttc" id="aclassbimap_1_1bidirectional__map_html_a40c1e68b6431da986028fb5d9d7a2b41"><div class="ttname"><a href="classbimap_1_1bidirectional__map.html#a40c1e68b6431da986028fb5d9d7a2b41">bimap::bidirectional_map::at</a></div><div class="ttdeci">auto at(const ForwardKey &amp;key) const -&gt; std::enable_if_t&lt; UniqueKeys, const InverseKey &amp; &gt;</div><div class="ttdef"><b>Definition:</b> bidirectional_map.hpp:713</div></div>
<div class="ttc" id="aclassbimap_1_1bidirectional__map_html_a20d7c9ce77dd7b536dcac6e2eead87fa"><div class="ttname"><a href="classbimap_1_1bidirectional__map.html#a20d7c9ce77dd7b536dcac6e2eead87fa">bimap::bidirectional_map::end</a></div><div class="ttdeci">iterator end() const noexcept(noexcept(std::declval&lt; ForwardMap &gt;().end()) &amp;&amp;iterator_ctor_nothrow)</div><div class="ttdef"><b>Definition:</b> bidirectional_map.hpp:557</div></div>
<div class="ttc" id="aclassbimap_1_1bidirectional__map_html"><div class="ttname"><a href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a></div><div class="ttdef"><b>Definition:</b> bidirectional_map.hpp:272</div></div>
<div class="ttc" id="aclassbimap_1_1bidirectional__map_html_a0947502711494ca13e834d07728d42dd"><div class="ttname"><a href="classbimap_1_1bidirectional__map.html#a0947502711494ca13e834d07728d42dd">bimap::bidirectional_map::find</a></div><div class="ttdeci">iterator find(const ForwardKey &amp;key) const noexcept(noexcept(std::declval&lt; ForwardMap &gt;().find(key)) &amp;&amp;iterator_ctor_nothrow)</div><div class="ttdef"><b>Definition:</b> bidirectional_map.hpp:567</div></div>
<div class="ttc" id="aclassbimap_1_1bidirectional__map_html_aa2c2540101bed9d42a489313af5fb8df"><div class="ttname"><a href="classbimap_1_1bidirectional__map.html#aa2c2540101bed9d42a489313af5fb8df">bimap::bidirectional_map::inverse</a></div><div class="ttdeci">constexpr auto inverse() noexcept -&gt; InverseBiMap &amp;</div><div class="ttdef"><b>Definition:</b> bidirectional_map.hpp:530</div></div>
<div class="ttc" id="aclassbimap_1_1bidirectional__map_html_a7ebfac1450e9aef4926db96a0365fe0c"><div class="ttname"><a href="classbimap_1_1bidirectional__map.html#a7ebfac1450e9aef4926db96a0365fe0c">bimap::bidirectional_map::begin</a></div><div class="ttdeci">iterator begin() const noexcept(noexcept(std::declval&lt; ForwardMap &gt;().begin()) &amp;&amp;iterator_ctor_nothrow)</div><div class="ttdef"><b>Definition:</b> bidirectional_map.hpp:548</div></div>
<div class="ttc" id="aclassbimap_1_1bidirectional__map_html_a1545d66d8b6ad045c54ba8e0df542f36"><div class="ttname"><a href="classbimap_1_1bidirectional__map.html#a1545d66d8b6ad045c54ba8e0df542f36">bimap::bidirectional_map::contains</a></div><div class="ttdeci">bool contains(const ForwardKey &amp;key) const noexcept(noexcept(std::declval&lt; bidirectional_map &gt;().find(key)) &amp;&amp;noexcept(std::declval&lt; iterator &gt;() !=std::declval&lt; iterator &gt;()))</div><div class="ttdef"><b>Definition:</b> bidirectional_map.hpp:700</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>

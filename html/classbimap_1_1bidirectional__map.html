<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bidirectional Map: bimap::bidirectional_map&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bidirectional Map
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebimap.html">bimap</a></li><li class="navelem"><a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">bimap::bidirectional_map&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Bidirectional associative container that supports efficient lookup in both directions.  
 <a href="classbimap_1_1bidirectional__map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bidirectional__map_8hpp_source.html">bidirectional_map.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classbimap_1_1bidirectional__map.html" title="Bidirectional associative container that supports efficient lookup in both directions.">bidirectional_map</a> iterator  <a href="classbimap_1_1bidirectional__map_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab6fca1c655e483508119bc8db3501ca8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#ab6fca1c655e483508119bc8db3501ca8">bidirectional_map</a> ()</td></tr>
<tr class="separator:ab6fca1c655e483508119bc8db3501ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc262ded0f8716123e0fde8b4d06e03a"><td class="memTemplParams" colspan="2">template&lt;typename InputIt &gt; </td></tr>
<tr class="memitem:adc262ded0f8716123e0fde8b4d06e03a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#adc262ded0f8716123e0fde8b4d06e03a">bidirectional_map</a> (InputIt start, InputIt <a class="el" href="classbimap_1_1bidirectional__map.html#a20d7c9ce77dd7b536dcac6e2eead87fa">end</a>)</td></tr>
<tr class="separator:adc262ded0f8716123e0fde8b4d06e03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68837ec6cc46f461b8bad24742558bd6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#a68837ec6cc46f461b8bad24742558bd6">bidirectional_map</a> (std::initializer_list&lt; std::pair&lt; ForwardKey, InverseKey &gt;&gt; init)</td></tr>
<tr class="separator:a68837ec6cc46f461b8bad24742558bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72443c7f22a6fb867d0eb8f3365488bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#a72443c7f22a6fb867d0eb8f3365488bd">bidirectional_map</a> (const <a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a> &amp;other)</td></tr>
<tr class="separator:a72443c7f22a6fb867d0eb8f3365488bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf8224a3833942f396c0aa3e3387146"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#a7bf8224a3833942f396c0aa3e3387146">swap</a> (<a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a> &amp;other) noexcept(std::is_nothrow_swappable_v&lt; ForwardMap &gt; &amp;&amp;std::is_nothrow_swappable_v&lt; InverseMap &gt;)</td></tr>
<tr class="separator:a7bf8224a3833942f396c0aa3e3387146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6ece6236b466ddf6e20ba9c8e5e550"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#a4a6ece6236b466ddf6e20ba9c8e5e550">bidirectional_map</a> (<a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a> &amp;&amp;other)</td></tr>
<tr class="separator:a4a6ece6236b466ddf6e20ba9c8e5e550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece03979801b20b2e770cebf17d36901"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#aece03979801b20b2e770cebf17d36901">operator=</a> (<a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a> other) noexcept(noexcept(std::declval&lt; <a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a> &gt;().<a class="el" href="classbimap_1_1bidirectional__map.html#a7bf8224a3833942f396c0aa3e3387146">swap</a>(other)))</td></tr>
<tr class="separator:aece03979801b20b2e770cebf17d36901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb2087b3fdd54c9eb0597af8a28c6aa"><td class="memTemplParams" colspan="2">template&lt;typename ... ARGS&gt; </td></tr>
<tr class="memitem:adeb2087b3fdd54c9eb0597af8a28c6aa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#adeb2087b3fdd54c9eb0597af8a28c6aa">emplace</a> (ARGS &amp;&amp;...args) -&gt; std::pair&lt; <a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a>, bool &gt;</td></tr>
<tr class="separator:adeb2087b3fdd54c9eb0597af8a28c6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf83f9f01ac48219ef7204e7df42c0aa"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#aaf83f9f01ac48219ef7204e7df42c0aa">size</a> () const noexcept(noexcept(std::declval&lt; ForwardMap &gt;().size()))</td></tr>
<tr class="separator:aaf83f9f01ac48219ef7204e7df42c0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e12063c76a126b89aeb87e37b1dcbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#af8e12063c76a126b89aeb87e37b1dcbd">empty</a> () const noexcept(noexcept(std::declval&lt; ForwardMap &gt;().empty()))</td></tr>
<tr class="separator:af8e12063c76a126b89aeb87e37b1dcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c2540101bed9d42a489313af5fb8df"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#aa2c2540101bed9d42a489313af5fb8df">inverse</a> () noexcept -&gt; <a class="el" href="classbimap_1_1bidirectional__map.html">InverseBiMap</a> &amp;</td></tr>
<tr class="separator:aa2c2540101bed9d42a489313af5fb8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab528b91dfee6077311000e3ab5e5a38b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#ab528b91dfee6077311000e3ab5e5a38b">inverse</a> () const noexcept -&gt; const <a class="el" href="classbimap_1_1bidirectional__map.html">InverseBiMap</a> &amp;</td></tr>
<tr class="separator:ab528b91dfee6077311000e3ab5e5a38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebfac1450e9aef4926db96a0365fe0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#a7ebfac1450e9aef4926db96a0365fe0c">begin</a> () const noexcept(noexcept(std::declval&lt; ForwardMap &gt;().begin()) &amp;&amp;iterator_ctor_nothrow)</td></tr>
<tr class="separator:a7ebfac1450e9aef4926db96a0365fe0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d7c9ce77dd7b536dcac6e2eead87fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#a20d7c9ce77dd7b536dcac6e2eead87fa">end</a> () const noexcept(noexcept(std::declval&lt; ForwardMap &gt;().end()) &amp;&amp;iterator_ctor_nothrow)</td></tr>
<tr class="separator:a20d7c9ce77dd7b536dcac6e2eead87fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0947502711494ca13e834d07728d42dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#a0947502711494ca13e834d07728d42dd">find</a> (const ForwardKey &amp;key) const noexcept(noexcept(std::declval&lt; ForwardMap &gt;().find(key)) &amp;&amp;iterator_ctor_nothrow)</td></tr>
<tr class="separator:a0947502711494ca13e834d07728d42dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0458ff3f2052cb76a9f84b0c816c14"><td class="memTemplParams" colspan="2">template&lt;REQUIRES_THAT(ForwardMap, std::declval&lt; _T_ &gt;().lower_bound(std::declval&lt; ForwardKey &gt;())) &gt; </td></tr>
<tr class="memitem:aea0458ff3f2052cb76a9f84b0c816c14"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#aea0458ff3f2052cb76a9f84b0c816c14">lower_bound</a> (const ForwardKey &amp;key) const noexcept(noexcept(std::declval&lt; ForwardMap &gt;().lower_bound(key)) &amp;&amp;iterator_ctor_nothrow) -&gt; <a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a></td></tr>
<tr class="separator:aea0458ff3f2052cb76a9f84b0c816c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0e37ee3471fd2f82ba587e9ca1a598"><td class="memTemplParams" colspan="2">template&lt;REQUIRES_THAT(ForwardMap, std::declval&lt; _T_ &gt;().upper_bound(std::declval&lt; ForwardKey &gt;())) &gt; </td></tr>
<tr class="memitem:a3a0e37ee3471fd2f82ba587e9ca1a598"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#a3a0e37ee3471fd2f82ba587e9ca1a598">upper_bound</a> (const ForwardKey &amp;key) const noexcept(noexcept(std::declval&lt; ForwardMap &gt;().upper_bound(key)) &amp;&amp;iterator_ctor_nothrow) -&gt; <a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a></td></tr>
<tr class="separator:a3a0e37ee3471fd2f82ba587e9ca1a598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a479cc29a7fa411086c7b8c81b74068"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#a3a479cc29a7fa411086c7b8c81b74068">equal_range</a> (const ForwardKey &amp;key) const noexcept(noexcept(std::declval&lt; ForwardMap &gt;().equal_range(key)) &amp;&amp;iterator_ctor_nothrow) -&gt; std::pair&lt; <a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a>, <a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:a3a479cc29a7fa411086c7b8c81b74068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5ba6029592154f22bbfe5eb5623fa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#aaa5ba6029592154f22bbfe5eb5623fa8">erase</a> (<a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a> pos)</td></tr>
<tr class="separator:aaa5ba6029592154f22bbfe5eb5623fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4435f61b2047d666e9993d3a3cdaae"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#a5c4435f61b2047d666e9993d3a3cdaae">erase</a> (const ForwardKey &amp;key)</td></tr>
<tr class="separator:a5c4435f61b2047d666e9993d3a3cdaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af131add3b2100f944c63ebf06ae90561"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#af131add3b2100f944c63ebf06ae90561">erase</a> (<a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a> first, <a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a> last)</td></tr>
<tr class="separator:af131add3b2100f944c63ebf06ae90561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509228e6cceb947aec83e058cadfe38a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#a509228e6cceb947aec83e058cadfe38a">operator==</a> (const <a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a> &amp;other) const noexcept(impl::traits::nothrow_comparable&lt; ForwardMap &gt; &amp;&amp;impl::traits::nothrow_comparable&lt; InverseMap &gt;)</td></tr>
<tr class="separator:a509228e6cceb947aec83e058cadfe38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44a60fa1cbfebf3fb140427332622c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#ac44a60fa1cbfebf3fb140427332622c2">operator!=</a> (const <a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a> &amp;other) const noexcept(noexcept(other==other))</td></tr>
<tr class="separator:ac44a60fa1cbfebf3fb140427332622c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd3d3a7b11fd19e4d2ebd003e65c07a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#a1cd3d3a7b11fd19e4d2ebd003e65c07a">clear</a> () noexcept(noexcept(std::declval&lt; ForwardMap &gt;().clear()) &amp;&amp;noexcept(std::declval&lt; InverseMap &gt;().clear()))</td></tr>
<tr class="separator:a1cd3d3a7b11fd19e4d2ebd003e65c07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1545d66d8b6ad045c54ba8e0df542f36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#a1545d66d8b6ad045c54ba8e0df542f36">contains</a> (const ForwardKey &amp;key) const noexcept(noexcept(std::declval&lt; <a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a> &gt;().<a class="el" href="classbimap_1_1bidirectional__map.html#a0947502711494ca13e834d07728d42dd">find</a>(key)) &amp;&amp;noexcept(std::declval&lt; <a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a> &gt;() !=std::declval&lt; <a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a> &gt;()))</td></tr>
<tr class="separator:a1545d66d8b6ad045c54ba8e0df542f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c1e68b6431da986028fb5d9d7a2b41"><td class="memTemplParams" colspan="2">template&lt;bool UniqueKeys = !impl::traits::is_multimap_v&lt;ForwardMap&gt;&gt; </td></tr>
<tr class="memitem:a40c1e68b6431da986028fb5d9d7a2b41"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbimap_1_1bidirectional__map.html#a40c1e68b6431da986028fb5d9d7a2b41">at</a> (const ForwardKey &amp;key) const -&gt; std::enable_if_t&lt; UniqueKeys, const InverseKey &amp; &gt;</td></tr>
<tr class="separator:a40c1e68b6431da986028fb5d9d7a2b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aee73f5ddb9af8c23effed00fa9c99a3a"><td class="memItemLeft" align="right" valign="top"><a id="aee73f5ddb9af8c23effed00fa9c99a3a"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>impl::AllocOncePointer&lt; bidirectional_map &gt;</b></td></tr>
<tr class="separator:aee73f5ddb9af8c23effed00fa9c99a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ForwardKey, typename InverseKey, template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt;<br />
class bimap::bidirectional_map&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;</h3>

<p>Bidirectional associative container that supports efficient lookup in both directions. </p>
<p>This class manages two unidirectional maps in order to enable bidirectional lookup. Neither items of type ForwardKey nor InverseKey can be modified. The map types for forward and for inverse lookup can be changed. The following map types are supported and have been tested:</p><ul>
<li>std::unordered_map (default for both lookup directions)</li>
<li>std::map</li>
<li>std::unordered_multimap</li>
<li>std::multimap <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardKey</td><td>Type of key used for forward lookup </td></tr>
    <tr><td class="paramname">InverseKey</td><td>Type of key used for inverse lookup </td></tr>
    <tr><td class="paramname">ForwardMapType</td><td>base map container used for forward lookup. Default is std::unordered_map </td></tr>
    <tr><td class="paramname">InverseMapType</td><td>base map container used for inverse lookup. Default is std::unordered_map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>when specifying the underlying map types, make sure that the respective types expect two template type arguments. Further arguments have to be deducible or have defaults. Using a custom map type not included in the list should be possible. Make sure that the typical map member functions (like find, emplace, etc) are supported and behave similar to the stl containers. If your map type is a multimap, you have to specialise the type trait <a class="el" href="structbimap_1_1impl_1_1traits_1_1is__multimap.html" title="type trait that indicates that a given typ is a multimap">impl::traits::is_multimap</a> </dd></dl>
</li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab6fca1c655e483508119bc8db3501ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fca1c655e483508119bc8db3501ca8">&#9670;&nbsp;</a></span>bidirectional_map() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::<a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an empty container </p>

</div>
</div>
<a id="adc262ded0f8716123e0fde8b4d06e03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc262ded0f8716123e0fde8b4d06e03a">&#9670;&nbsp;</a></span>bidirectional_map() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;typename InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::<a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates the container from the iterator range [start, end) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>Type of iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>bein of range (inclusive) </td></tr>
    <tr><td class="paramname">end</td><td>end of range (exclusive) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68837ec6cc46f461b8bad24742558bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68837ec6cc46f461b8bad24742558bd6">&#9670;&nbsp;</a></span>bidirectional_map() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::<a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::pair&lt; ForwardKey, InverseKey &gt;&gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates the container from the given initializer list </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>list of value pairs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72443c7f22a6fb867d0eb8f3365488bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72443c7f22a6fb867d0eb8f3365488bd">&#9670;&nbsp;</a></span>bidirectional_map() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::<a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a6ece6236b466ddf6e20ba9c8e5e550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6ece6236b466ddf6e20ba9c8e5e550">&#9670;&nbsp;</a></span>bidirectional_map() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::<a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. Moves objects from other. If ForwardMapType and InverseMapType support moving, no objects are copied </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this move CTor may throw exceptions if memory allocation fails </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classbimap_1_1bidirectional__map_a4a6ece6236b466ddf6e20ba9c8e5e550_cgraph.png" border="0" usemap="#classbimap_1_1bidirectional__map_a4a6ece6236b466ddf6e20ba9c8e5e550_cgraph" alt=""/></div>
<map name="classbimap_1_1bidirectional__map_a4a6ece6236b466ddf6e20ba9c8e5e550_cgraph" id="classbimap_1_1bidirectional__map_a4a6ece6236b466ddf6e20ba9c8e5e550_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,188,47"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#a7bf8224a3833942f396c0aa3e3387146" title=" " alt="" coords="236,5,388,47"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a40c1e68b6431da986028fb5d9d7a2b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c1e68b6431da986028fb5d9d7a2b41">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;bool UniqueKeys = !impl::traits::is_multimap_v&lt;ForwardMap&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const ForwardKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; std::enable_if_t&lt;UniqueKeys, const InverseKey &amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value found by the given key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key used for lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to found value </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out_of_range</td><td>if ey does not exist </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>not available when using multimap as base container </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classbimap_1_1bidirectional__map_a40c1e68b6431da986028fb5d9d7a2b41_cgraph.png" border="0" usemap="#classbimap_1_1bidirectional__map_a40c1e68b6431da986028fb5d9d7a2b41_cgraph" alt=""/></div>
<map name="classbimap_1_1bidirectional__map_a40c1e68b6431da986028fb5d9d7a2b41_cgraph" id="classbimap_1_1bidirectional__map_a40c1e68b6431da986028fb5d9d7a2b41_cgraph">
<area shape="rect" title=" " alt="" coords="5,39,157,80"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#a20d7c9ce77dd7b536dcac6e2eead87fa" title=" " alt="" coords="205,5,357,47"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#a0947502711494ca13e834d07728d42dd" title=" " alt="" coords="205,71,357,112"/>
</map>
</div>

</div>
</div>
<a id="a7ebfac1450e9aef4926db96a0365fe0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ebfac1450e9aef4926db96a0365fe0c">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a> <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>iterator to first element </p><dl class="section note"><dt>Note</dt><dd>Ordering of objects depends on the underlying container specified by ForwardMpaType and InverseMapType. Ordering of forward access may be different from ordering of inverse access </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to first element of forward lookup map </dd></dl>

</div>
</div>
<a id="a1cd3d3a7b11fd19e4d2ebd003e65c07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd3d3a7b11fd19e4d2ebd003e65c07a">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases all elements from the container </p>

</div>
</div>
<a id="a1545d66d8b6ad045c54ba8e0df542f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1545d66d8b6ad045c54ba8e0df542f36">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const ForwardKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if a certain key can be found </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key used for lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if key can be found, false otherwise </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classbimap_1_1bidirectional__map_a1545d66d8b6ad045c54ba8e0df542f36_cgraph.png" border="0" usemap="#classbimap_1_1bidirectional__map_a1545d66d8b6ad045c54ba8e0df542f36_cgraph" alt=""/></div>
<map name="classbimap_1_1bidirectional__map_a1545d66d8b6ad045c54ba8e0df542f36_cgraph" id="classbimap_1_1bidirectional__map_a1545d66d8b6ad045c54ba8e0df542f36_cgraph">
<area shape="rect" title=" " alt="" coords="5,39,157,80"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#a20d7c9ce77dd7b536dcac6e2eead87fa" title=" " alt="" coords="205,5,357,47"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#a0947502711494ca13e834d07728d42dd" title=" " alt="" coords="205,71,357,112"/>
</map>
</div>

</div>
</div>
<a id="adeb2087b3fdd54c9eb0597af8a28c6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb2087b3fdd54c9eb0597af8a28c6aa">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;typename ... ARGS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; std::pair&lt;<a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a>, bool&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs elements in place. If a pair of values with same ForwardKey or same InverseKey already exists and the corresponding container requires unique keys, then no insertion happens. For example, if std::multiset is used for forward lookup and the map contains the following pair :(a, b) then inserting (a, b') is possible whereas (a', b) will not be inserted since the inverse lookup is carried out by std::unordered_map </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ARGS</td><td>argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>arguments used to construct elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair(iterator to inserted element or already existing element, bool whether insertion happened) </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classbimap_1_1bidirectional__map_adeb2087b3fdd54c9eb0597af8a28c6aa_cgraph.png" border="0" usemap="#classbimap_1_1bidirectional__map_adeb2087b3fdd54c9eb0597af8a28c6aa_cgraph" alt=""/></div>
<map name="classbimap_1_1bidirectional__map_adeb2087b3fdd54c9eb0597af8a28c6aa_cgraph" id="classbimap_1_1bidirectional__map_adeb2087b3fdd54c9eb0597af8a28c6aa_cgraph">
<area shape="rect" title=" " alt="" coords="5,39,157,80"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#a20d7c9ce77dd7b536dcac6e2eead87fa" title=" " alt="" coords="205,5,357,47"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#a0947502711494ca13e834d07728d42dd" title=" " alt="" coords="205,71,357,112"/>
</map>
</div>

</div>
</div>
<a id="af8e12063c76a126b89aeb87e37b1dcbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e12063c76a126b89aeb87e37b1dcbd">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether container is empty </p><dl class="section return"><dt>Returns</dt><dd>true if container is empty </dd></dl>

</div>
</div>
<a id="a20d7c9ce77dd7b536dcac6e2eead87fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d7c9ce77dd7b536dcac6e2eead87fa">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a> <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>iterator to the past the end element. This iterator does not point to anything. Access results in undefined behaviour </p><dl class="section return"><dt>Returns</dt><dd>iterator to past the end element of forward lookup map </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classbimap_1_1bidirectional__map_a20d7c9ce77dd7b536dcac6e2eead87fa_icgraph.png" border="0" usemap="#classbimap_1_1bidirectional__map_a20d7c9ce77dd7b536dcac6e2eead87fa_icgraph" alt=""/></div>
<map name="classbimap_1_1bidirectional__map_a20d7c9ce77dd7b536dcac6e2eead87fa_icgraph" id="classbimap_1_1bidirectional__map_a20d7c9ce77dd7b536dcac6e2eead87fa_icgraph">
<area shape="rect" title=" " alt="" coords="205,104,357,145"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#a40c1e68b6431da986028fb5d9d7a2b41" title=" " alt="" coords="5,5,157,47"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#a1545d66d8b6ad045c54ba8e0df542f36" title=" " alt="" coords="5,71,157,112"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#adeb2087b3fdd54c9eb0597af8a28c6aa" title=" " alt="" coords="5,136,157,177"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#aaa5ba6029592154f22bbfe5eb5623fa8" title=" " alt="" coords="5,201,157,243"/>
</map>
</div>

</div>
</div>
<a id="a3a479cc29a7fa411086c7b8c81b74068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a479cc29a7fa411086c7b8c81b74068">&#9670;&nbsp;</a></span>equal_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const ForwardKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; std::pair&lt;<a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a>, <a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a>&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls equal_range on the underlying container. For more information see documentation of the respective container type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key used for lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator range containing equal elements </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classbimap_1_1bidirectional__map_a3a479cc29a7fa411086c7b8c81b74068_icgraph.png" border="0" usemap="#classbimap_1_1bidirectional__map_a3a479cc29a7fa411086c7b8c81b74068_icgraph" alt=""/></div>
<map name="classbimap_1_1bidirectional__map_a3a479cc29a7fa411086c7b8c81b74068_icgraph" id="classbimap_1_1bidirectional__map_a3a479cc29a7fa411086c7b8c81b74068_icgraph">
<area shape="rect" title=" " alt="" coords="205,5,357,47"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#a5c4435f61b2047d666e9993d3a3cdaae" title=" " alt="" coords="5,5,157,47"/>
</map>
</div>

</div>
</div>
<a id="a5c4435f61b2047d666e9993d3a3cdaae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4435f61b2047d666e9993d3a3cdaae">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const ForwardKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases all elements with forward key equivalent to key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key used for lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of erased elements </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classbimap_1_1bidirectional__map_a5c4435f61b2047d666e9993d3a3cdaae_cgraph.png" border="0" usemap="#classbimap_1_1bidirectional__map_a5c4435f61b2047d666e9993d3a3cdaae_cgraph" alt=""/></div>
<map name="classbimap_1_1bidirectional__map_a5c4435f61b2047d666e9993d3a3cdaae_cgraph" id="classbimap_1_1bidirectional__map_a5c4435f61b2047d666e9993d3a3cdaae_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,157,47"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#a3a479cc29a7fa411086c7b8c81b74068" title=" " alt="" coords="205,5,357,47"/>
</map>
</div>

</div>
</div>
<a id="af131add3b2100f944c63ebf06ae90561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af131add3b2100f944c63ebf06ae90561">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a> <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases all elements in the range [first, last) which must be a valid range in *this </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>start of the range (inclusive) </td></tr>
    <tr><td class="paramname">last</td><td>end of the range (exclusive) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator following the last removed element </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classbimap_1_1bidirectional__map_af131add3b2100f944c63ebf06ae90561_cgraph.png" border="0" usemap="#classbimap_1_1bidirectional__map_af131add3b2100f944c63ebf06ae90561_cgraph" alt=""/></div>
<map name="classbimap_1_1bidirectional__map_af131add3b2100f944c63ebf06ae90561_cgraph" id="classbimap_1_1bidirectional__map_af131add3b2100f944c63ebf06ae90561_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,157,47"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#a20d7c9ce77dd7b536dcac6e2eead87fa" title=" " alt="" coords="205,5,357,47"/>
</map>
</div>

</div>
</div>
<a id="aaa5ba6029592154f22bbfe5eb5623fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5ba6029592154f22bbfe5eb5623fa8">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a> <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases the element at position pos </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>iterator to the element to remove. if pos == <a class="el" href="classbimap_1_1bidirectional__map.html#a20d7c9ce77dd7b536dcac6e2eead87fa">end()</a>, this method does nothing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the next element in the container </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classbimap_1_1bidirectional__map_aaa5ba6029592154f22bbfe5eb5623fa8_cgraph.png" border="0" usemap="#classbimap_1_1bidirectional__map_aaa5ba6029592154f22bbfe5eb5623fa8_cgraph" alt=""/></div>
<map name="classbimap_1_1bidirectional__map_aaa5ba6029592154f22bbfe5eb5623fa8_cgraph" id="classbimap_1_1bidirectional__map_aaa5ba6029592154f22bbfe5eb5623fa8_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,157,47"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#a20d7c9ce77dd7b536dcac6e2eead87fa" title=" " alt="" coords="205,5,357,47"/>
</map>
</div>

</div>
</div>
<a id="a0947502711494ca13e834d07728d42dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0947502711494ca13e834d07728d42dd">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a> <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const ForwardKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds an element with forward key equivalent to key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key used for lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to an element with forward key equivalent to key. If no such element is found, past-the-end (see <a class="el" href="classbimap_1_1bidirectional__map.html#a20d7c9ce77dd7b536dcac6e2eead87fa">end()</a>) iterator is returned. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classbimap_1_1bidirectional__map_a0947502711494ca13e834d07728d42dd_icgraph.png" border="0" usemap="#classbimap_1_1bidirectional__map_a0947502711494ca13e834d07728d42dd_icgraph" alt=""/></div>
<map name="classbimap_1_1bidirectional__map_a0947502711494ca13e834d07728d42dd_icgraph" id="classbimap_1_1bidirectional__map_a0947502711494ca13e834d07728d42dd_icgraph">
<area shape="rect" title=" " alt="" coords="205,71,357,112"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#a40c1e68b6431da986028fb5d9d7a2b41" title=" " alt="" coords="5,5,157,47"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#a1545d66d8b6ad045c54ba8e0df542f36" title=" " alt="" coords="5,71,157,112"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#adeb2087b3fdd54c9eb0597af8a28c6aa" title=" " alt="" coords="5,136,157,177"/>
</map>
</div>

</div>
</div>
<a id="ab528b91dfee6077311000e3ab5e5a38b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab528b91dfee6077311000e3ab5e5a38b">&#9670;&nbsp;</a></span>inverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; const <a class="el" href="classbimap_1_1bidirectional__map.html">InverseBiMap</a> &amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Readonly access to the inverted map for reverse lookup </p><dl class="section return"><dt>Returns</dt><dd>const reference to inverted map </dd></dl>

</div>
</div>
<a id="aa2c2540101bed9d42a489313af5fb8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c2540101bed9d42a489313af5fb8df">&#9670;&nbsp;</a></span>inverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classbimap_1_1bidirectional__map.html">InverseBiMap</a> &amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to the inverted map for reverse lookup or insertion </p><dl class="section return"><dt>Returns</dt><dd>Reference to inverted map </dd></dl>

</div>
</div>
<a id="aea0458ff3f2052cb76a9f84b0c816c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0458ff3f2052cb76a9f84b0c816c14">&#9670;&nbsp;</a></span>lower_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;REQUIRES_THAT(ForwardMap, std::declval&lt; _T_ &gt;().lower_bound(std::declval&lt; ForwardKey &gt;())) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const ForwardKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls lower_bound on the underlying container. For more information see documentation of the respective container type. Only available when using sorted containers like std::map </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key used for lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lower bound iterator </dd></dl>

</div>
</div>
<a id="ac44a60fa1cbfebf3fb140427332622c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44a60fa1cbfebf3fb140427332622c2">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares container by elements, see operator== </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>right hand side </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if *this != other </dd></dl>

</div>
</div>
<a id="aece03979801b20b2e770cebf17d36901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece03979801b20b2e770cebf17d36901">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a>&amp; <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to *this </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classbimap_1_1bidirectional__map_aece03979801b20b2e770cebf17d36901_cgraph.png" border="0" usemap="#classbimap_1_1bidirectional__map_aece03979801b20b2e770cebf17d36901_cgraph" alt=""/></div>
<map name="classbimap_1_1bidirectional__map_aece03979801b20b2e770cebf17d36901_cgraph" id="classbimap_1_1bidirectional__map_aece03979801b20b2e770cebf17d36901_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,157,47"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#a7bf8224a3833942f396c0aa3e3387146" title=" " alt="" coords="205,5,357,47"/>
</map>
</div>

</div>
</div>
<a id="a509228e6cceb947aec83e058cadfe38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509228e6cceb947aec83e058cadfe38a">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares underlying containers </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>right hand side </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both forward mapping and inverse mapping are equivalent </dd></dl>
<dl class="section note"><dt>Note</dt><dd>for more details see documentation of the used underlying containers. If the default containers are used, the underlying std::unordered_maps are compared </dd></dl>

</div>
</div>
<a id="aaf83f9f01ac48219ef7204e7df42c0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf83f9f01ac48219ef7204e7df42c0aa">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of contained elements </p><dl class="section return"><dt>Returns</dt><dd>Number of contained elements </dd></dl>

</div>
</div>
<a id="a7bf8224a3833942f396c0aa3e3387146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf8224a3833942f396c0aa3e3387146">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbimap_1_1bidirectional__map.html">bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps the content of the containers. If ForwardMapType and InverseMapType support moving, no objects are copied </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>swap target </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classbimap_1_1bidirectional__map_a7bf8224a3833942f396c0aa3e3387146_icgraph.png" border="0" usemap="#classbimap_1_1bidirectional__map_a7bf8224a3833942f396c0aa3e3387146_icgraph" alt=""/></div>
<map name="classbimap_1_1bidirectional__map_a7bf8224a3833942f396c0aa3e3387146_icgraph" id="classbimap_1_1bidirectional__map_a7bf8224a3833942f396c0aa3e3387146_icgraph">
<area shape="rect" title=" " alt="" coords="236,39,388,80"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#a4a6ece6236b466ddf6e20ba9c8e5e550" title=" " alt="" coords="5,5,188,47"/>
<area shape="rect" href="classbimap_1_1bidirectional__map.html#aece03979801b20b2e770cebf17d36901" title=" " alt="" coords="21,71,173,112"/>
</map>
</div>

</div>
</div>
<a id="a3a0e37ee3471fd2f82ba587e9ca1a598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0e37ee3471fd2f82ba587e9ca1a598">&#9670;&nbsp;</a></span>upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardKey , typename InverseKey , template&lt; typename ... &gt; typename ForwardMapType = std::unordered_map, template&lt; typename ... &gt; typename InverseMapType = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;REQUIRES_THAT(ForwardMap, std::declval&lt; _T_ &gt;().upper_bound(std::declval&lt; ForwardKey &gt;())) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbimap_1_1bidirectional__map.html">bimap::bidirectional_map</a>&lt; ForwardKey, InverseKey, ForwardMapType, InverseMapType &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const ForwardKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classbimap_1_1bidirectional__map_1_1iterator.html">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls upper_bound on the underlying container. For more information see documentation of the respective container type. Only available when using sorted containers like std::map </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key used for lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>upper bound iterator </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bidirectional__map_8hpp_source.html">bidirectional_map.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
